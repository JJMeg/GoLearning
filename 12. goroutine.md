#### goroutine
1. 串行执行
```Go
func loop()  {
	for i := 0; i<10 ;i++{
		fmt.Print("%d",i)
	}
}

func main()  {
	loop()
	loop()
}
//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

2. 一个goroutine
主线程一个、goroutine又开一个线程，goroutine没来得及跑loop，主线程已经结束
```Go
func loop()  {
	for i := 0; i<10 ;i++{
		fmt.Print("%d",i)
	}
}

func main()  {
	go loop()//启动一个goroutine
	loop()
}
//0 1 2 3 4 5 6 7 8 9
```

3. 一个goroutine，并延迟一秒结束主线程
```Go
func loop()  {
	for i := 0; i<10 ;i++{
		fmt.Print("%d",i)
	}
}

func main()  {
	go loop()//启动一个goroutine
	loop()
	time.Sleep(time.Second)//停止一秒，类似java中的join阻塞
}
//0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

#### 信道
goroutine之间互相通讯的东西，发送和接收消息，实质是在goroutine之间共享内存
1. 信道可以阻塞goroutine线程
```Go
var channel chan int = make(chan int)
// channel := make(chan int)

func main()  {
	var messages chan string = make(chan string)
	go func (message string)  {
		messages <- message // 存消息
	}
	fmt.Println(<-messages)//取消息
}
```
- 信道的存消息和取消息都是阻塞的，无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好
```Go
var ch chan int = make(chan int)

func foo()  {
	ch <- 0//存消息，如果没有其他goroutine来取走这个数据，那么挂起foo，直到main函数把这个0取走
}

func main()  {
	go foo()
	<- ch//从ch取消息，如果ch中没有数据，就挂起main线程，直到foo函数往ch内放数据
}
```

2. 问题：goroutine已经执行完毕了如何去通知main线程？
```Go
var complete chan int = make(chan int)

func loop()  {
	for i:=0 ; i<10 ;i++{
		fmt.Print("%d",i)
	}
	complete <- 0
}

func main()  {
	go loop()
	<- complete //直到线程跑完，取到消息
}
```
- 取数据：无缓冲的信道不存储数据，只负责数据的流通，从信道取数据时，若没有数据在信道中，那么当前线程阻塞
- 存数据：没有其他goroutine拿走数据，数据还在信道中，当前这个线程也阻塞

3. 死锁案例：
```Go
func main()  {
	var ch := make(chan,int)
	ch <- 1//死锁了，没有线程取走这个数据
	fmt.Println("wrong")
}
```
